#include <iostream>
#include <fstream>
#include <sstream>
#include <map>
#include <string>
#include "junction.h"
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <unistd.h>




using namespace std;

#define CREST 0 
#define SEEKSV 1 
const char *kVersion = "1.3.1";

class Info
{
	public:
		int up_support_read_no;
		int down_support_read_no;
		string sv_type;
		int status;
		Info() { }
		Info(int up_no, int down_no, string type, int sta) {up_support_read_no = up_no; down_support_read_no = down_no; sv_type = type; status = sta; }
		void set_value(int up_no, int down_no, string type, int sta) {
			up_support_read_no = up_no;
			down_support_read_no = down_no; 
			sv_type = type; 
			status = sta; 
		}
};

void Usage(string prog, string command);
void ReadSVInfo(string file, map<Junction, Info> &junction2info, map<pair<string, int>, int> &start2end, string chr);
void ReadCNVInfo(string file, map<Junction, Info> &junction2info, string chr);
void ReadCrestOrSeeksvInfo(string file, ofstream &fout, map<Junction, Info> &junction2info, const char *tag, int file_type);
void MergeNear(ofstream &fout, map<Junction, Info> &junction2info, const char *tag, int search_length);
void CompareTargeToControl(ofstream &fout, map<Junction, Info> &control_junction2info, map<Junction, Info> &target_junction2info, int search_length);
void OutputDifferentResult(ofstream &fout, map<Junction, Info> &junction2info, const char *tag);
void Output(ofstream &fout, map<Junction, Info>::iterator map_it, const char *tag);
void CallSimu(int argc, char *argv[]);
void CallCrestOrSeeksv(int argc, char *argv[]);

void ReadNareaFile(string file, map<pair<string, int>, int> &start2end);


int main(int argc, char *argv[])
{
	if (argc == 1)
	{
		cerr << "Version " << kVersion << endl;
		cerr << "Usage: " << argv[0] << " <command> [options]\n"
			 << "command: simu\t\tcompare crest or seeksv results with simulation data\n"
			 << "         crest\t\tcompare crest or seeksv results with crest results\n"
			 << "         seeksv\t\tcompare crest or seeksv results with seeksv results" << endl;

		exit(1);
	}
	else if (argc == 2)
	{
		string prog = argv[0], command = argv[1];
		Usage(prog, command);
		exit(1);
	}
	else
	{
		string prog = argv[0], command = argv[1];
		if (command == "simu")
		{
			CallSimu(argc, argv);
		}
		else if (command == "crest" || command == "seeksv")
		{
			CallCrestOrSeeksv(argc, argv);
		}
		else
		{
			cerr << "Unrecognized command '" << command << "'" << endl;
			exit(1);
		}
	}

	return 0;
}

void Usage(string prog, string command)
{
	if ("simu" == command)
	{
		cerr << "Usage:\n" << prog << " " << command << " [options] <simu sv information file> <simu cnv information file> <target sv results(default seeksv)> <output file>\n" << endl;
		cerr << "Options:\n";
		cerr << "                    -c           chromosome, default [chr17]\n";
		cerr << "                    -t     	  target file is generated by CREST\n";
		cerr << "                    -n <FILE>    path of N-area file(select this option to mask SVs come from N-area\n";
		exit(1);
	}
	else if ("crest" == command)
	{
		cerr << "Usage:\n" << prog << " " << command << " [options] <crest results(control)> <target sv results(default seeksv> <output file>" << endl;
		cerr << "Options:\n";
		cerr << "                    -t     target file is generated by CREST\n";
		exit(1);
	}
	else if ("seeksv" == command)
	{
		cerr << "Usage:\n" << prog << " " << command << " [options] <seeksv results(control)> <target sv results(default seeksv> <output file>" << endl;
		cerr << "Options:\n";
		cerr << "                    -t     target file is generated by CREST\n";
		exit(1);
	}
	else
	{
		cerr << "unrecognized command '" << command << "'" << endl;
		exit(1);
	}
}


void ReadSVInfo(string file, map<Junction, Info> &junction2info, map<pair<string, int>, int> &start2end, string chr)
{
	ifstream fin(file.c_str());
	if (!fin) 
	{
		cerr << "Cannot open file " << file << endl;
		exit(1);
	}

	map<pair<string, int>, int>::iterator map_it;

	string type, temp;
	int start_pos, end_pos, length;
	char allele, insType, period;
	Info info(0, 0, "INV", 0);
	int is_overlap = 0;
	while (fin >> type)
	{
		if (type == "inv" || type == "INV")
		{
			fin >> start_pos >> length >> allele >> insType >> period;
			end_pos = start_pos + length - 1;

			map_it = start2end.lower_bound(make_pair(chr, start_pos));	
			
			if (map_it != start2end.end())
			{
				if (map_it->first.first == chr && end_pos > map_it->first.second)
					is_overlap = 1;
			}
			
			if (map_it != start2end.begin())
			{
				--map_it;
				if (map_it->first.first == chr && start_pos < map_it->first.second)
					is_overlap = 1;
			}
			
			if (is_overlap == 0)
			{
				Junction junction(chr, start_pos - 1, '+', chr, end_pos, '-');
				junction2info.insert(make_pair(junction, info));
				junction.set_value(chr, start_pos, '-', chr, end_pos + 1, '+');
				junction2info.insert(make_pair(junction, info));
			}
		}
		getline(fin, temp);
	}
}

void ReadCNVInfo(string file, map<Junction, Info> &junction2info, map<pair<string, int>, int> &start2end, string chr)
{
	ifstream fin(file.c_str());
	if (!fin) 
	{
		cerr << "Cannot open file " << file << endl;
		exit(1);
	}
	string type, temp;
	int start_pos, end_pos, length;
	char allele, period;
	string allele_pos, al_pos;

	int is_overlap = 0;

	map<pair<string, int>, int>::iterator map_it;

	Info info_ins(0, 0, "INS", 0);
	Info info_del(0, 0, "DEL", 0);

	while (fin >> type)
	{
		if (type == "lins")
		{
			fin >> start_pos >> end_pos >> allele >> period >> allele_pos;
			istringstream strm(allele_pos);
			while (getline(strm, al_pos, ';'))
			{
				al_pos = al_pos.substr(2);
				istringstream istrm(al_pos);
				int insert_pos;
				istrm >> insert_pos;
				istrm.clear();


				map_it = start2end.upper_bound(make_pair(chr, insert_pos));	
				if (map_it != start2end.begin())
				{
					--map_it;
					if (map_it->first.first == chr && map_it->first.second >= insert_pos)
						is_overlap = 1;
				}
				
				if (is_overlap == 0)
				{
					map_it = start2end.lower_bound(make_pair(chr, start_pos));	
					
					if (map_it != start2end.end())
					{
						if (map_it->first.first == chr && end_pos > map_it->first.second)
							is_overlap = 1;
					}
					
					if (map_it != start2end.begin())
					{
						--map_it;
						if (map_it->first.first == chr && start_pos < map_it->first.second)
							is_overlap = 1;
					}
			
				}

				if (is_overlap == 0)
				{
					Junction junction(chr, insert_pos - 1, '+', chr, start_pos, '+');
					junction2info.insert(make_pair(junction, info_ins));
					junction.set_value(chr, end_pos, '+', chr, insert_pos, '+');
					junction2info.insert(make_pair(junction, info_ins));
				}
			}
		}
		else if (type == "ldel")
		{
			fin >> start_pos >> end_pos >> allele >> period;

			map_it = start2end.lower_bound(make_pair(chr, start_pos));	
			
			if (map_it != start2end.end())
			{
				if (map_it->first.first == chr && end_pos > map_it->first.second)
					is_overlap = 1;
			}
			
			if (map_it != start2end.begin())
			{
				--map_it;
				if (map_it->first.first == chr && start_pos < map_it->first.second)
					is_overlap = 1;
			}
			

			if (is_overlap == 0)
			{
				Junction junction(chr, start_pos - 1, '+', chr, end_pos + 1, '+');
				junction2info.insert(make_pair(junction, info_del));
			}
		}
		getline(fin, temp);
	}
}

void ReadCrestOrSeeksvInfo(string file, ofstream &fout, map<Junction, Info> &junction2info, const char *tag, int file_type)
{
	ifstream fin(file.c_str());
	if (!fin)
	{
		cerr << "Cannot open file " << file << endl;
		exit(1);
	}
	string up_chr, down_chr, sv_type, temp;
	

	int up_pos, down_pos, up_support_reads_no, down_support_reads_no, microhomology_length, abnormal_read_pair_no;
	char up_strand, down_strand;
	Junction junction;
	Info info;
	while (fin >> up_chr)
	{
		if (up_chr[0] == '@' || up_chr == "left_chr")
		{
			getline(fin, temp);
			continue;
		}
		if (file_type == CREST)
		{
			fin >> up_pos >> up_strand >> up_support_reads_no >> down_chr >> down_pos >> down_strand >> down_support_reads_no >> sv_type;
			if (up_strand != down_strand && make_pair(up_chr, up_pos) > make_pair(down_chr, down_pos))
			{
				junction.set_value(down_chr, down_pos, up_strand, up_chr, up_pos, down_strand);
				info.set_value(down_support_reads_no, up_support_reads_no, sv_type, 0);
			}
			else
			{
				junction.set_value(up_chr, up_pos, up_strand, down_chr, down_pos, down_strand);
				info.set_value(up_support_reads_no, down_support_reads_no, sv_type, 0);
			}
		}
		else if (file_type == SEEKSV)
		{
			fin >> up_pos >> up_strand >> up_support_reads_no >> down_chr >> down_pos >> down_strand >> down_support_reads_no >> microhomology_length >> abnormal_read_pair_no >> sv_type;
			junction.set_value(up_chr, up_pos, up_strand, down_chr, down_pos, down_strand);
			info.set_value(up_support_reads_no, down_support_reads_no, sv_type, 0);
		}
		getline(fin, temp);
		if (junction2info.count(junction) == 1)
		{
			fout << tag << '\t' << up_chr << '\t' << up_pos << '\t' << up_strand << '\t' << up_support_reads_no << '\t'
				 << down_chr << '\t' << down_pos << '\t' << down_strand << '\t' << down_support_reads_no << '\t' << sv_type << endl;
		}
		else
			junction2info.insert(make_pair(junction, info));
	}
	cout <<  junction2info.size() << endl;
}


void MergeNear(ofstream &fout, map<Junction, Info> &junction2info, const char *tag, int search_length)
{
	map<Junction, Info>::iterator map_it = junction2info.begin(), map_it1;
	while (map_it != junction2info.end())
	{
		map_it1 = map_it;
		map_it1++;
		while (map_it1 != junction2info.end() && map_it->first.up_chr == map_it1->first.up_chr && map_it->first.down_chr == map_it1->first.down_chr && map_it->first.up_strand == map_it1->first.up_strand && map_it->first.down_strand == map_it1->first.down_strand && abs(map_it1->first.up_pos - map_it->first.up_pos) <= search_length)
		{
			if (abs(map_it1->first.down_pos - map_it->first.down_pos) <= search_length)
			{
				Output(fout, map_it1, tag);
				junction2info.erase(map_it1++);
			}
			else
				map_it1++;
		}
		++map_it;
	}
}



void CompareTargeToControl(ofstream &fout, map<Junction, Info> &control_junction2info, map<Junction, Info> &target_junction2info, int search_length)
{
	map<Junction, Info>::iterator target_it = target_junction2info.begin(), control_it, control_it1;
	while(target_it != target_junction2info.end())
	{
		control_it = control_junction2info.find(target_it->first), control_it1;
		int mark = 0;
		if (control_it == control_junction2info.end())
		{
			control_it = control_junction2info.lower_bound(target_it->first);
			control_it1 = control_it;
			while (control_it != control_junction2info.end() && control_it->first.up_chr == target_it->first.up_chr && control_it->first.down_chr == target_it->first.down_chr && control_it->first.up_strand == target_it->first.up_strand && control_it->first.down_strand == target_it->first.down_strand && abs(control_it->first.up_pos - target_it->first.up_pos) <= search_length)
			{
				if(abs(target_it->first.down_pos - control_it->first.down_pos) <= search_length)
				{
					Output(fout, control_it, "control_share");
					Output(fout, target_it, "target_share");
					control_it->second.status = 1;
					target_it->second.status = 1;
					mark = 1;
					break;
				}
				++control_it;
			}
			if (mark == 0)
			{
				control_it = control_it1;
				if (control_it != control_junction2info.begin())
				{
					--control_it;
					while (control_it != control_junction2info.begin() && control_it->first.up_chr == target_it->first.up_chr && control_it->first.down_chr == target_it->first.down_chr && control_it->first.up_strand == target_it->first.up_strand && control_it->first.down_strand == target_it->first.down_strand && abs(control_it->first.up_pos - target_it->first.up_pos) <= search_length)
					{
						if (abs(target_it->first.down_pos - control_it->first.down_pos) <= search_length)
						{
							Output(fout, control_it, "control_share");
							Output(fout, target_it, "target_share");
							control_it->second.status = 1;
							target_it->second.status = 1;
							mark = 1;
							break;
						}
						--control_it;
					}
					if (control_it == control_junction2info.begin() && control_it->first.up_chr == target_it->first.up_chr && control_it->first.down_chr == target_it->first.down_chr && control_it->first.up_strand == target_it->first.up_strand && control_it->first.down_strand == target_it->first.down_strand && abs(control_it->first.up_pos - target_it->first.up_pos) <= search_length && abs(target_it->first.down_pos - control_it->first.down_pos) <= search_length)
					{
						Output(fout, control_it, "control_share");
						Output(fout, target_it, "target_share");
						control_it->second.status = 1;
						target_it->second.status = 1;
						mark = 1;
					}
				}
			}
		}
		else
		{
			Output(fout, control_it, "control_share");
			Output(fout, target_it, "target_share");
			control_it->second.status = 1;
			target_it->second.status = 1;
		}
		target_it++;
	}
}


void OutputDifferentResult(ofstream &fout, map<Junction, Info> &junction2info, const char *tag)
{
	map<Junction, Info>::iterator map_it = junction2info.begin();
	while (map_it != junction2info.end())
	{
		if (map_it->second.status == 0)
			Output(fout, map_it, tag);
		++map_it;
	}
}

void Output(ofstream &fout, map<Junction, Info>::iterator map_it, const char *tag)
{
	fout << tag << '\t' << map_it->first.up_chr << '\t' << map_it->first.up_pos << '\t' << map_it->first.up_strand << '\t'  << map_it->second.up_support_read_no << '\t' << map_it->first.down_chr << '\t' << map_it->first.down_pos << '\t' << map_it->first.down_strand << '\t' << map_it->second.down_support_read_no << '\t' << map_it->second.sv_type << endl;
}

void CallSimu(int argc, char *argv[])
{
	char c;
	int type = SEEKSV;
	string narea_file;
	string chr;
	while ((c = getopt(argc-1, argv+1, "c:n:t")) >= 0)
	{
		switch (c)
		{
		case 'c': chr = optarg; break;
		case 't': type = CREST; break;
		case 'n': narea_file = optarg; break;
		}
	}
	optind++;
	string prog = argv[0], command = argv[1];

	if (argc != optind + 4)
	{
		Usage(prog, command);
		exit(1);
	}
	map<pair<string, int>, int> start2end;
	if (!narea_file.empty())
	{
		ReadNareaFile(narea_file, start2end);
	}

	cerr << prog << '\t' << command << endl;
	string file = argv[optind++];
	map<Junction, Info> simu_junction2info, target_junction2info;
	ReadSVInfo(file, simu_junction2info, start2end, chr);
	file = argv[optind++];
	ReadCNVInfo(file, simu_junction2info, start2end, chr);
	file = argv[optind++];
	string out_file = argv[optind++];
	ofstream fout(out_file.c_str());
	if (!fout) { cerr << "Cannot open file " << out_file << endl; exit(1); }
	ReadCrestOrSeeksvInfo(file, fout, target_junction2info, "target_repeat", type);
	MergeNear(fout, target_junction2info, "target_repeat", 50);
	CompareTargeToControl(fout, simu_junction2info, target_junction2info, 50);
	OutputDifferentResult(fout, simu_junction2info, "control_only");
	OutputDifferentResult(fout, target_junction2info, "target_only");
}


void CallCrestOrSeeksv(int argc, char *argv[])
{
	char c;
	int type = SEEKSV;
	while ((c = getopt(argc-1, argv+1, "t")) >= 0)
	{
		switch (c)
		{
		case 't': type = CREST; break;
		}
	}
	optind++;
	string prog = argv[0], command = argv[1];
	if (argc != optind + 3) 
	{
		Usage(prog, command);
		exit(1);
	}
	string control_file = argv[optind++];
	string target_file = argv[optind++]; 
	string out_file = argv[optind++];
	ofstream fout(out_file.c_str());
	if (!fout) { cerr << "Cannot open file " << out_file << endl; exit(1); }
	map<Junction, Info> control_junction2info, target_junction2info;
	if (command == "crest")
		ReadCrestOrSeeksvInfo(control_file, fout, control_junction2info, "control_repeat", CREST);
	else
		ReadCrestOrSeeksvInfo(control_file, fout, control_junction2info, "control_repeat", SEEKSV);
	MergeNear(fout, control_junction2info, "control_repeat", 50);
	ReadCrestOrSeeksvInfo(target_file, fout, target_junction2info, "target_repeat", type);
	MergeNear(fout, target_junction2info, "target_repeat", 50);
	CompareTargeToControl(fout, control_junction2info, target_junction2info, 50);
	OutputDifferentResult(fout, control_junction2info, "control_only");
	OutputDifferentResult(fout, target_junction2info, "target_only");
}

void ReadNareaFile(string file, map<pair<string, int>, int> &start2end)
{
	ifstream fin(file.c_str());
	string chr, temp;
	int beg, end;
	while (fin >> chr >> beg >> end)
	{
		getline(fin, temp);
		start2end.insert(make_pair(make_pair(chr, beg), end));
	}
}




